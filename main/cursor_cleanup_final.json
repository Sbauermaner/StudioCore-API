{
    "project_final_cleanup_plan": {
      "meta": {
        "status_reference": "AKTUELLER_STATUS_ANALYSE_2025_AKTUALISIERT.md",
        "previous_phases": "Phases 1-11 COMPLETED (90% Stability)",
        "objective": "Address remaining P2 tasks: Implement Stubs, Fill Placeholders, Optimize TLP, and harden UI."
      },
      "phases": [
        {
          "id": "PHASE_12_STUB_IMPLEMENTATION",
          "name": "Resilience Stubs",
          "priority": "MEDIUM",
          "description": "Ensure fallback mechanisms return valid data instead of crashing.",
          "target_files": [
            "studiocore/fallback.py",
            "auto_sync_openapi.py"
          ],
          "tasks": [
            {
              "task_id": "12.1",
              "issue": "`StudioCoreFallback.analyze` raises RuntimeError.",
              "location": "studiocore/fallback.py",
              "action": "Implement a minimal `analyze` method that returns a valid default dictionary (using `DEFAULT_CONFIG` structure) instead of raising an exception."
            },
            {
              "task_id": "12.2",
              "issue": "`auto_sync_openapi` raises SystemExit.",
              "location": "auto_sync_openapi.py",
              "action": "Replace `raise SystemExit` with a simple print log ('Sync skipped - not implemented') to prevent pipeline crashes during CI/CD checks."
            }
          ]
        },
        {
          "id": "PHASE_13_TLP_OPTIMIZATION",
          "name": "TLP Caching Strategy",
          "priority": "MEDIUM",
          "description": "Prevent TLP engine from re-analyzing text multiple times per request.",
          "target_files": [
            "studiocore/tlp_engine.py"
          ],
          "tasks": [
            {
              "task_id": "13.1",
              "issue": "TLP score methods (`truth_score`, etc.) trigger full analysis independently.",
              "location": "studiocore/tlp_engine.py",
              "action": "Implement hash-based caching in `analyze(text)`. Store results in `self._cache[hash(text)]` and reuse them if the text hasn't changed."
            }
          ]
        },
        {
          "id": "PHASE_14_PLACEHOLDER_CLEANUP",
          "name": "Fill Critical Placeholders",
          "priority": "LOW",
          "description": "Implement basic logic for empty `pass` methods.",
          "target_files": [
            "studiocore/adapter.py",
            "studiocore/logger_runtime.py"
          ],
          "tasks": [
            {
              "task_id": "14.1",
              "issue": "`Adapter` and `LoggerRuntime` methods are empty (`pass`).",
              "location": "studiocore/adapter.py & studiocore/logger_runtime.py",
              "action": "Implement basic logging or pass-through logic instead of empty pass statements to ensure tracebility."
            }
          ]
        },
        {
          "id": "PHASE_15_UI_RESILIENCE",
          "name": "UI Fault Tolerance",
          "priority": "LOW",
          "description": "Prevent UI crashes on partial data.",
          "target_files": [
            "app.py"
          ],
          "tasks": [
            {
              "task_id": "15.1",
              "issue": "UI crashes if optional keys are missing in result.",
              "location": "app.py",
              "action": "Wrap data extraction logic with `result.get(key, safe_default)` patterns to handle partial analysis results gracefully."
            }
          ]
        }
      ]
    }
  }