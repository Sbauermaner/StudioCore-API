# Проблемы логики

## 1. Глобальный экземпляр ядра не потокобезопасен
- **Файл/строки:** `app.py` 49–170, `studiocore/core_v6.py` 46–70, `studiocore/logical_engines.py` 77–92.
- **Что не так:** FastAPI создаёт один глобальный `CORE = get_core()` и использует его для всех запросов `/api/predict`. Внутри `StudioCoreV6` хранятся stateful-объекты (`TextStructureEngine` накапливает `_last_sections`, `_structured_meta`), которые изменяются в ходе анализа.
- **Почему это ломает логику:** При конкурентной обработке запросов состояние последнего анализа протекает в другой запрос: секции, метаданные и подсказки могут подменяться, а запись в списки без синхронизации приводит к гонкам (особенно в async-сервере Uvicorn с несколькими воркерами).
- **Исправление:** Убирать глобальный синглтон — либо создавать новый `get_core()` для каждого запроса, либо оборачивать `CORE` в пул/мьютекс и делать движки внутри `StudioCoreV6` статeless (например, пересоздавать `TextStructureEngine` в `analyze`).

## 2. Нет повторной загрузки после стартовой ошибки
- **Файл/строки:** `app.py` 49–66 и 141–154.
- **Что не так:** При исключении в `get_core()` глобальные `CORE` и `CORE_LOADED` фиксируются в `None/False`. Все последующие запросы сразу получают 500, даже если окружение уже готово и `get_core()` мог бы сработать позже.
- **Почему это ломает логику:** Единственный сбой при старте (например, временное отсутствие файла) делает API навсегда нерабочим до рестарта контейнера, хотя `/status` умеет пересоздавать ядро.
- **Исправление:** Добавить ленивую повторную попытку внутри `api_predict` (при `CORE is None` снова вызвать `get_core()` и обновить флаг) или внедрить механизм health-check, который заменяет `CORE` после успешной загрузки.

## 3. В ответ попадает dataclass, который FastAPI не сериализует
- **Файл/строки:** `studiocore/rde_engine.py` 9–47, `studiocore/core_v6.py` 720–801, `app.py` 168–170.
- **Что не так:** `RhythmDynamicsEmotionEngine.compose()` возвращает `RDESnapshot` (dataclass). Объект кладётся в `result["rde_summary"]`, а затем `JSONResponse(content=result, …)` пытается сериализовать словарь с dataclass внутри.
- **Почему это ломает логику:** Стандартный JSON-энкодер FastAPI/Starlette не умеет сериализовать произвольные dataclass-экземпляры без `jsonable_encoder`, поэтому ответ падает с `TypeError: Object of type RDESnapshot is not JSON serializable`.
- **Исправление:** Перед возвратом конвертировать `RDESnapshot` в словарь (`dataclasses.asdict` или `jsonable_encoder`) либо возвращать обычный dict из `compose()`.

## 4. Метаданные секций всегда пустые
- **Файл/строки:** `studiocore/logical_engines.py` 25–34 и 81–124.
- **Что не так:** Код пытается импортировать `get_last_section_metadata` из `text_utils`, но такой функции нет. Срабатывает fallback, который возвращает пустой список, поэтому `TextStructureEngine.section_metadata()` всегда отдаёт пустые данные независимо от входного текста.
- **Почему это ломает логику:** `SectionParser` и последующие подсистемы (структурные подсказки, аннотации, подсветка секций в UI) не получают реальные заголовки `[Verse 1]`, `Припев:` и т.п., из-за чего теряются пользовательские подсказки и снижается точность.
- **Исправление:** Реализовать `text_utils.get_last_section_metadata()` (например, возвращать результат `extract_sections`) и убрать заглушку, либо хранить метаданные в самом `TextStructureEngine` при парсинге.


## Аудит после рефакторинга — 19 ноября 2025
Критических проблем логики больше не обнаружено. Проект полностью потокобезопасен, теги сохраняются корректно, каждый запрос изолирован.
- Небольшое замечание: блок перевода по-прежнему работает в режиме заглушки, поэтому при подключении реального сервиса потребуется снять предупреждение и обновить флаг `was_translated`.
