Отчёт аудита StudioCore — директория studiocore/* (полное сканирование)
Дата: 2025-11-21 (UTC)

1) Фактический пайплайн и порядок выполнения
- Реальный порядок StudioCoreV6.analyze: очистка/определение языка → сбор семантических подсказок и секций → backend_analyze с последовательными вызовами эмоций, TLP, section_intelligence, BPM/тональности/ритма/REM/zero_pulse, жанровых расчётов, аннотаций и финального слитого результата. Конструктор и analyze фиксируют, что совместно используются два разных EmotionEngine (LegacyEmotionEngine и EmotionEngine) плюс динамический слой, что задаёт реальный граф движков для всех подсистем.【F:studiocore/core_v6.py†L20-L187】
- Внутри _backend_analyze по-прежнему вызывается монолитный LegacyCore и весь его вывод укладывается в поле "legacy" без синхронизации статуса ошибок; даже когда legacy_result содержит "error", пайплайн продолжает двигаться и метрики BPM/жанра могут использовать неполные legacy-сигналы. Отсутствует явный флаг разрыва цепочки, что скрывает сбои базового ядра и нарушает требование выявлять пропущенные или зависшие шаги.【F:studiocore/core_v6.py†L262-L335】
- FusionEngineV64 и Suno prompt builder (adapter.build_suno_prompt) не участвуют в цепочке: они нигде не создаются и не вызываются из analyze/_backend_analyze, поэтому стадия единой "fusion" сборки и полноценного Suno prompt остаётся пропущенной в фактическом порядке выполнения. Это означает отсутствие финальной нормализации BPM/тональности/жанра и пропуск запрошенного пользователем Suno prompt builder шага, что делает пайплайн неполным.【F:studiocore/fusion_engine_v64.py†L1-L130】【F:studiocore/adapter.py†L25-L123】

2) Согласованность движков (эмо/тон/ритм/жанр/аннотации)
- Вокальный слой модифицируется дважды: сначала override_engine.apply_to_vocals применяется сразу после детекции (vocal_payload), позже тот же override_engine вызывается в _apply_user_overrides_once на уже изменённом payload. Двойная мутация даёт риск конфликтов и разночтений между diagnostics и итоговым блоком vocal, нарушая консистентность вокального движка.【F:studiocore/core_v6.py†L448-L486】【F:studiocore/core_v6.py†L1628-L1645】
- Тональный слой рассчитывает emotion_modulation (ToneSyncEngine.emotion_modulation) и записывает её в служебный словарь _tone_dynamic, но итоговый tonality_payload, который выдаётся наружу, не включает эти поправки. Внешние потребители получают ключ/модальность без учёта эмоциональной модуляции, что ломает согласованность тонального и эмоционального движков и нарушает обещанную синестезию «эмоция→тон».【F:studiocore/core_v6.py†L530-L563】
- Разделительный парсер вручную перезаписывает приватное поле TextStructureEngine._section_metadata и возвращает metadata для каждой секции, но эти метаданные могут не совпасть по длине с auto_section_split, если туда попадёт пустая секция. Это создаёт рассинхрон между section_headers и фактическим списком секций, что приводит к неверному раскрашиванию/аннотациям в downstream движках (section parser / section intelligence / annotation engine).【F:studiocore/section_parser.py†L47-L75】【F:studiocore/logical_engines.py†L94-L150】

3) Логические ошибки, протечки классов/состояния и сериализация
- EmotionEngineV64 использует класс-поле WEIGHTS и логарифмически обновляет его на каждом вызове process; т.к. это класс-атрибут, все экземпляры и запросы делят одно состояние. Это приводит к меж-сеансовой утечке «весов» и непредсказуемым результатам анализа, нарушая требование изоляции и сериализуемости (выход зависит от истории запуска).【F:studiocore/emotion_engine.py†L29-L135】
- AutoIntegrator автоматически выполняет git add/commit/push и правку файлов (создание __init__.py) при запуске execute(). Это побочный эффект вне анализа, который может изменять рабочее дерево/репозиторий без подтверждения и вводить несериализуемые артефакты (вплоть до пустых __init__.py), тем самым ломая ожидаемую чистоту пайплайна и целостность архива движков.【F:studiocore/auto_integrator.py†L31-L105】
- В _apply_user_overrides_once возвращается копия adjustments, но метод не помечает результат как неизменяемый и продолжает менять исходный payload после помещения флага _overrides_applied. При повторных вызовах результат зависит от предыдущего состояния словаря, что создаёт «stale memory» и нелинейные итерации оверрайдов, если ядро повторно использует объект анализа.【F:studiocore/core_v6.py†L1596-L1655】

4) Риски некорректного результата текстового анализа
- Недетектируемые сбои монолита (см. п.1) приводят к тому, что BPM/тональность/жанр продолжают вычисляться с пустыми или ошибочными legacy-слоями, но без явного флага ошибки. Клиенты получают валидно выглядящий результат при фактическом отсутствии данных, что может «сломать» внешние решения (неправильный BPM/ключ/жанр) и Suno prompt builder, который полагается на эти поля.【F:studiocore/core_v6.py†L262-L335】【F:studiocore/adapter.py†L80-L118】
- Пропуск fusion/suno prompt сборки (см. п.1) оставляет движки genre_matrix/annotation/vocals без итоговой нормализации и генерации Suno промпта, что приводит к неполному API-ответу и несогласованности с документацией (заявлена поддержка Suno prompt builder и fusion summary).【F:studiocore/fusion_engine_v64.py†L1-L130】【F:studiocore/adapter.py†L25-L123】
- Класс WEIGHTS в EmotionEngineV64 и приватная перезапись _section_metadata (см. п.2–3) создают скрытые глобальные состояния; при последовательных анализах возможен «залипший» жанровый/эмоциональный баланс и неверные аннотации для новых текстов, что прямо влияет на корректность текстового анализа (старые веса и метаданные переносятся на новые входы).【F:studiocore/emotion_engine.py†L66-L119】【F:studiocore/section_parser.py†L47-L75】

Отчёт не вносит изменений в код и фиксирует выявленные несоответствия для дальнейшего устранения.
